__本题解为C/C++题解，Java和Python选手请根据题解思路自行写出代码__

# L1-1 代码胜于雄辩
### 直接输出即可
```c++
#include <stdio.h>
int main() {
    printf("No PHP can be used in this contest");
    return 0;
}
```

# L1-2 收水费
### 按照题目要求模拟即可
```c++
#include<stdio.h>
int main () {
    int a;
    scanf("%d",&a);
    if(a<=100) printf("%d\n",2*a);
    else if(a>500) printf("%d\n",10*a);
    else printf("%d\n",2*a+2*(a-100));
    return 0;
}
```

# L1-3 日期
### 我们知道月份肯定是后两位 所以月份 为 $n\%100$, 年份为 $n/100$ 如果是是只有两位那肯定 年份是小于$100的，我们再去加上他应该有的年份就行。(如果用字符串处理也可以，但是没有这样做方便)
```c++
#include <stdio.h>
int main() {
    int n;
    scanf("%d",&n);
    int year = n/100;
    int month = n%100;
    if(year<24)year+=2000;
    if(year<100&&year>=24)year+=1900;
    printf("%d-%02d",year,month);
}
```

# L1-4 回文数
### 我们将数字当成字符串读入后比较反着和正着是否一样即可（pypy3和java需要使用快读快写）
```c++
#include <stdio.h>
#include <string.h>
int main() {
	int t;
	scanf("%d",&t);
	while(t--){
		char str[20];
		scanf("%s",str);
		int n = strlen(str) - 1;
		int flag = 0;
		for(int i =0 ;i < n;i++){
			if(str[i] != str[n-i]){
				flag=1;
			}
		}
		if(flag==1)printf("false\n");
		else printf("true\n");
		
	}
}
```

# L1-5 yihan的新函数
### 判断数a的奇偶性，如果是奇数，则把数a中的偶数位全部改成0；如果是偶数，则把数a中的奇数位全部改成0

### 例如：12211是奇数，修改后就变成了10201；4212是偶数，修改后就变成了4010

### 根据解释可知新函数的定义为，如果一个整数是偶数，就把奇数位上的数字变成0，如果是奇数，就把偶数为的数字变成0，位数的定义即为个位为第一位，十位为第二位以此类推。

### 然后需要求出$n$个数字经过新函数转换后的总和。

### 因为数字最大为$10^5$，所以只需要暴力按位拆分，然后求和即可

### 按位拆分然后修改

```c++
int cnt=1,ans1=1;
if(a%2==0){
    while(a){
        if(cnt%2==0){
            ans+=a%10*ans1;
        }
        a/=10;
        ans1*=10;
        cnt++;
    }
}
else{
    while(a){
        if(cnt%2==1){
            ans+=a%10*ans1;
        }
        a/=10;
        ans1*=10;
        cnt++;
    }
}
```
###  以下是详细代码

```c++
#include<bits/stdc++.h>
using namespace std;
void solve(){
    int n;
    cin>>n;
    int ans=0;
    for(int i=1;i<=n;i++){
        int a;
        cin>>a;
        int cnt=1,ans1=1;
        if(a%2==0){
            while(a){
                if(cnt%2==0){
                    ans+=a%10*ans1;
                }
                a/=10;
                ans1*=10;
                cnt++;
            }
        }
        else{
            while(a){
                if(cnt%2==1){
                    ans+=a%10*ans1;
                }
                a/=10;
                ans1*=10;
                cnt++;
            }
        }
    }
    cout<<ans<<endl;
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    int t=1;
//	cin>>t;
    while(t--) solve();
    return 0;
}
```

# L1-6 二进制

### 本题的核心在于模拟二进制相加的过程，由于只有$a$和$b$两个二进制串，所以只需要循环遍历，按位相加，最后进行进位操作即可
### 以下是详细代码

```c++
#include<bits/stdc++.h>
using namespace std;
char a[100010],b[100010]; // a,b字符串
int a1[100010],b1[100010]; // 逆转a,b字符串，并将char转换为int
int c[100010]; // 存相加结果
int main(){
    scanf("%s",a);
    scanf("%s",b);
    int lena=strlen(a); // a字符串长度
    int lenb=strlen(b); // b字符串长度
    for(int i=lena-1;i>=0;i--){ // 逆转a字符串,并将char转换成int
        a1[lena-i-1]=a[i]-'0';
    }
    for(int i=lenb-1;i>=0;i--){ // 逆转b字符串，并将char转换成int
        b1[lenb-i-1]=b[i]-'0';
    }
    for(int i=0;i<max(lena,lenb);i++){
        c[i]=a1[i]+b1[i]; // 求和
    }
    for(int i=0;i<max(lena,lenb);i++){
        if(c[i]>=2){ // 进位操作
            c[i+1]+=c[i]/2;
            c[i]%=2;
        }
    }
    int f=0;
    for(int i=max(lena,lenb)+1;i>=0;i--){
        if(c[i]==0&&f==0) continue; // 如果为前导零就跳过
        else{
            cout<<c[i];
            f=1;
        }
    }
    return 0;
}
```

# L1-7 大山中的学院

### 因为只有山脉会提供加成，并且$n$,$m$的值最大不超过$10^3$，所以支架遍历每一个位置，如果当前位置是山脉，就遍历它的上下左右，然后加上加成值，最后进行比较，即可得出答案

### 以下是详细代码

```c++
#include<bits/stdc++.h>
using namespace std;
int cnt[1010][1010]; // 加成值
char mp[1010][1010]; // 地图
int a[1000010]; // 山脉的加成值
int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};
int main(){
    int n,m,k;
    cin>>n>>m>>k;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>mp[i][j];
        }
    }
    for(int i=1;i<=k;i++) cin>>a[i];
    int tot=0; // 标记山脉数量
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(mp[i][j]=='*'){ // 如果当前是山脉
                tot++; // 当前是第几座山脉
                for(int l=0;l<4;l++){
                    int x=i+dx[l],y=j+dy[l]; // 遍历上下左右四个方向
                    if(x>=1&&x<=n&&y>=1&&y<=m){ // 如果在地图范围内
                        if(mp[x][y]=='-'){ // 如果遍历到的是空地
                            cnt[x][y]+=a[tot]; // 加上当前山脉的加成
                        }
                    }
                }
            }
        }
    }
    int x=0,y=0; // 记录最大加成值的山脉的位置
    int ans=0; // 记录最大加成值
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(mp[i][j]=='-'){ // 空地才能建学院
                if(cnt[i][j]>ans){ // 当前加成值大于最大加成值
                    ans=cnt[i][j]; // 更新最大加成值
                    x=i,y=j; // 更新位置
                }
            }
        }
    }
    cout<<x<<" "<<y<<endl;
    cout<<ans<<endl;
    return 0;
}
```


# L1-8 堆积木
- 现从箱子中取出一个积木，在现有的塔中寻找塔顶积木比它大且它与塔顶差值最小的塔，将它放置在塔顶。
- 若同时出现多座塔的塔顶都比它大，且差值相同，则将这块积木放置在这些塔中最高的那座塔上。
- 若高度也相同，则放置在最先搭建的塔上。
- 若没找到满足条件的塔，就新建一座塔，让取出的积木成为新建的塔的塔顶

### 题目一共有三种操作，取出一个新的积木

### 第一步，遍历已经搭建的塔去寻找塔顶比它大且跟他差值最小的塔，然后对塔顶进行更新，让取出的塔成为新的塔顶。如果存在多座塔的塔顶都比它大，且差值相同，就选择高度最高的塔。如果高度也相同就选择最先搭建的塔。

### 如果第一步没有找到合适的塔，就新建一座塔。

### 可以使用队列或者用数组模拟队列，存放塔顶的值，然后每取出一块积木就遍历队列，在已有的塔顶里面寻找满足条件的塔，如果没有满足要求的塔，就将取出的积木存入队列，作为新建的塔。

### 以下是详细代码

```c++
#include<bits/stdc++.h>
using namespace std;
void solve(){
	int n;
	cin>>n;
	vector<int> a,cnt; // vector数组模拟队列，可以用普通数组替代
	for(int i=1;i<=n;i++){
		int aa;
		cin>>aa;
		if(a.size()==0){ // 如果没有塔就新建一座塔
			a.push_back(aa); // 存入塔顶大小
			cnt.push_back(1); // 存入塔的高度
		}
		else{
			int pos=-1,cc=1e9;
			for(int j=0;j<a.size();j++){ //遍历已有的塔去寻找，因为是按顺序遍历，所以如果有相同符合要求的塔，一定是先建好的塔先被遍历
				if(a[j]>aa){ 
					int c=a[j]-aa; // 存放差值
					if(c<cc){
						pos=j; // 计入找到的塔的位置
						cc=c;
					}
					else if(c==cc){ // 如果差值相等，比较塔的高度
						if(cnt[j]>cnt[pos]){
							pos=j; // 更新塔的位置
						}
					}
				}
			}
			if(pos==-1){  //如果没有找到，新建一座塔
				a.push_back(aa);
				cnt.push_back(1);
			}
			else{
				a[pos]=aa; //更新塔顶的大小
				cnt[pos]++; // 塔高度加1
			}
		}
	}
	int ans=0;
	for(int i=0;i<a.size();i++) ans=max(ans,cnt[i]);// 寻找塔的高度的最大值
	cout<<ans<<" "<<a.size()<<endl;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	int t=1;
//	cin>>t;
	while(t--) solve();
	return 0;
}
```


# L2-1 买！买！买！（dfs/并查集）：
### 问题可以抽象为询问图内连通块的个数连通块中有环的个数。在每次dfs的时候初始化一个值$flag=1$ 代表当前遍历的连通块中是否有环，在dfs的过程中标记经过的灯塔，若发现要遍历的灯塔已经被标记过了，则讲$flag$ 赋值为0，若完成一个连通块的标记之后flag值任然为1，则可以认为这个联通块中没有环。直接dfs遍历每个连通块即可。

### dfs写法

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 2e5+10;
int vis[N];
int fg;
vector<vector<int>> adj;
void dfs(int u,int fa)
{
	vis[u]=1;
	for(auto to:adj[u]) if(to!=fa)
	{
		if(vis[to])
		{
			fg=1;
			continue;
		}
		dfs(to,u);
	}
}
void solve()
{
	int n,m;cin>>n>>m;
	adj.resize(n+1);
	for(int i=1;i<=m;i++)
	{
		int u,v;cin>>u>>v;
		adj[u].push_back(v);
		adj[v].push_back(u);
	}
	int res=0,ans=0;
	for(int i=1;i<=n;i++)
	{
		if(!vis[i])
		{
			fg=0;
			res++;
			dfs(i,0);
			ans+=fg;
		}
	}
	cout<<res<<'\n'<<ans<<'\n';
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	int t=1;
	while(t--) solve();
}
```

### 并查集写法
```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 2e5 + 10;
int n, m;
int f[N];
bool st[N];

int find(int k)
{
    return f[k] == k ? k : f[k] = find(f[k]);
}

int main()
{
    cin >> n >> m;
    for(int i = 1; i <= n; i ++) f[i] = i;
    while(m --)
    {
        int a, b;
        cin >> a >> b;
        a = find(a), b = find(b);
        if(a != b)
        {
            f[a] = b;
            st[b] |= st[a];
        }
        else st[a] = true;
    }
    int cnt1 = 0, cnt2 = 0;
    for(int i = 1; i <= n; i ++)
    {
        if(f[i] == i)
        {
            cnt1 ++;
            if(st[i]) cnt2 ++;
        }
    }
    cout << cnt1 << ' ' << cnt2;
}
```

# L2-2 发牌&洗牌（模拟）

### 因为洗牌方式为：一次洗牌过后，从上到下依次是：⌊2k​⌋+1,1,⌊2k​⌋+2,2,⌊2k​⌋+3,3,...,k,⌊2k​⌋（只有偶数张牌）。意思就是将牌堆对半分，然后两边一边取一张插入牌堆，重复这个操作，直到牌全部整合成一堆

### 所以我们只需要暴力模拟洗牌的过程即可。例如：
```c++
for(int i=2;i<=k;i+=2) {
    y[i].a=x[i/2].a;
    y[i].b=x[i/2].b;
    y[i-1].a=x[k/2+(i/2)].a;
    y[i-1].b=x[k/2+(i/2)].b;
}
for(int i=1;i<=k;i++){
    x[i].a=y[i].a,x[i].b=y[i].b;
}
```
### 发牌方式的介绍：从第 1 张牌开始，从上到下依次将第 i 张牌给第 [(i−1) mod n+1] 号玩家，直到每人四张牌为止。意思即为按$1-n$的顺序将牌分给每个人，可能存在每个人到手牌数不一样，因为$k$不一定整除$n$。

### 如果牌堆数不够第$p$个人拿到4张牌即输出$"Error$:$cards$ $not$ $enough"$。否则输出$p$号玩家拿到的牌的前四张。同样暴力输出即可
```c++
int q=0;
for(int i=1;i<=k&&q<4;i++)
{
    if((i-1)%n+1==p){
        if(x[i].a==1){
            cout<<"A";
        }
        else if(x[i].a==11){
            cout<<"J";
        }
        else if(x[i].a==12){
            cout<<"Q";
        }
        else if(x[i].a==13){
            cout<<"K";
        }
        else{
            cout<<x[i].a;
        }
        cout<<x[i].b<<endl;
        q++;
    }
}
```

### 以下是详细代码
```c++
#include<bits/stdc++.h>
using namespace std;
struct sb{
    int a;
    string b;
}x[100010],y[100010];
void solve(){
    long long n,k,m,p;
    cin>>n>>k>>m>>p;
    for(int i=1;i<=k;i++){
        cin>>x[i].a>>x[i].b;
    }
    if(k<n*3+p){
        cout<<"Error:cards not enough"<<endl;
        return ;
    }
    while(m--){
        for(int i=2;i<=k;i+=2) {
            y[i].a=x[i/2].a;
            y[i].b=x[i/2].b;
            y[i-1].a=x[k/2+(i/2)].a;
            y[i-1].b=x[k/2+(i/2)].b;
        }
        for(int i=1;i<=k;i++){
            x[i].a=y[i].a,x[i].b=y[i].b;
        }
    }
    int q=0;
    for(int i=1;i<=k&&q<4;i++)
    {
        if((i-1)%n+1==p){
            if(x[i].a==1){
                cout<<"A";
            }
            else if(x[i].a==11){
                cout<<"J";
            }
            else if(x[i].a==12){
                cout<<"Q";
            }
            else if(x[i].a==13){
                cout<<"K";
            }
            else{
                cout<<x[i].a;
            }
            cout<<x[i].b<<endl;
            q++;
        }
    }	
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    int t=1;
//	cin>>t;
    while(t--) solve();
    return 0;
}
```

# Gwen的小剪刀(二分/最大生成树+最小生成树)

### 本题的核心在于找出可以使得图联通的边中 $W$ 值最大的边，这是一个经典的二分最小生成树问题，即每次二分边权，利用并查集判断大于 $W$ 的所有边能能否使得图连通 ，也可以通过对 $W$ 进行一次最大生成树，这颗最大生成树中 $W$ 最小的边即为 使得图连通的最小值最大的 $W$ 记为 $W_{min}$，当前最小值最大的边的权值为$W_{min}$，将所有 $W$ 值小于 $W_{min}$ 的边舍弃掉,对剩下的边进行一次对 $C$ 的最小生成树即可。最小生成树的权值总合即为答案。
### 二分写法
```c++
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
using pii = pair<int,int> ;
//#define int long long
#define endl '\n'
const int INF = 0x3f3f3f3f;
void solve()
{
	cin>>n>>m;
	vector<array<int,4>> adj;
	int l=1e9,r=0;
	for(int i=1;i<=m;i++)
	{
		int x,y,w,v;cin>>x>>y>>w>>v;
		adj.push_back({x,y,w,v});
		r=max(r,w);
        l=min(l,w);
	}
	auto cmp = [&](array<int,4> a,array<int,4> b)
	{
		return a[2]<b[2];
	};
	sort(adj.begin(),adj.end(),cmp);
	auto check = [&](int x)
	{
		vector<int> f(n+1);
		function<int(int)> find = [&](int x)
		{
			return x==f[x]?x:f[x]=find(f[x]);
		};
		for(int i=1;i<=n;i++) f[i]=i;
		int cnt=0;
		for(auto [a,b,w,v]:adj)
		{
			if(w<x) continue;
			a=find(a),b=find(b);
			if(a!=b)
			{
				f[b]=f[a];
				cnt++;
			}
		}
		return cnt==n-1;
	};
	while(l<=r)
	{
		int mid=l+r>>1;
		if(check(mid)) l=mid+1;
		else r=mid-1;
	}
	vector<int> f(n+1);
	function<int(int)> find = [&](int x)
	{
		return x==f[x]?x:f[x]=find(f[x]);
	};
	ll ans=0;
	for(int i=1;i<=n;i++) f[i]=i;
	auto cmp1 = [&](array<int,4> a,array<int,4> b)
	{
		return a[3]<b[3];
	};
	sort(adj.begin(),adj.end(),cmp1);
	for(auto [a,b,w,v]:adj)
	{
		if(w<r) continue;
		a=find(a),b=find(b);
		if(a!=b)
		{
			f[b]=f[a];
			ans+=v;
		}
	}
	cout<<r<<endl<<ans<<endl;
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	int t=1;
	while(t--) solve();
}
```

### 最大生成树+最小生成树
```c++
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N = 2e5+10;
const int M = 2e5+10;
struct node{
	int x,y,w,c;
}e[M];
int tot;
int head[N];
int n,m;
int f[N];
int find(int x){
	if(x==f[x])return x;
	return f[x]=find(f[x]);
}
bool cmp(node a, node b){
	return a.w > b.w;
}
ll result = 0;
ll W;
void kruskal(){
	sort(e,e+tot,cmp);
	for(int i=0;i<tot;i++){
		int u = find(e[i].x);
		int v = find(e[i].y);
		if(u!=v){
			f[u]=v;
			W=e[i].w;
		}
	}
}
bool cmp1(node a, node b){
	return a.c < b.c;
}
void kruskal1(){
	sort(e,e+tot,cmp1);
	for(int i=0;i<tot;i++){
		if(e[i].w<W) continue;
		int u = find(e[i].x);
		int v = find(e[i].y);
		if(u!=v){
			f[u]=v;
			result+=e[i].c;
		}
	}
}
void solve(){
	cin >> n >> m;
	ll ans2 = 0;
	for(int i=1;i<=n;i++)f[i]=i;
	for(int i=1;i<=m;i++){
		int x,y,z,c;
		cin >> x >> y >> z >> c;
		e[tot++]={x,y,z,c};
	}
	kruskal();
    //由于kruskcal算法的特性,最后一次加入最大生成树的边一定是这颗生成树中W值最小的
	for(int i=1;i<=n;i++)f[i]=i;
	kruskal1();
	cout << W << endl;
	cout << result << endl;
	
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	int t=1;
	while (t--) solve();
}
```

# L2-4 超时空之恋（多层图最短路）
### 多层图最短路裸题，一开始用链式前向星加入同层道路，后建立不同层相同点之间的路径。最后用spfa或者dijkstra跑一遍最短路即可

__细节：最后给出的地牢出现时间是随机的，需要对地牢出现的时间排序，因为下次出现地牢上一次就会消失__
```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define PII  pair<long long , long long>
struct node{
	int to,ne,w;
}e[4000100];
const int inf = 4557430888798830399;
bool cmp(PII x,PII y){ return x.second<y.second; }
int tot;
int dist[4000100],head[4000010];
bool vis[4000010];
void add(int a, int b, int w)
{
	e[tot].w=w;
	e[tot].ne=head[a];
	e[tot].to=b;
	head[a]=tot++;
}
void dijkstra(int s)
{
	memset(dist,0x3f,sizeof(dist));
	dist[s]=0;
	priority_queue<PII,vector<PII>,greater<PII>> heap;
	heap.push({0, s});
	while (heap.size()) {
		auto [dis, v] = heap.top(); heap.pop();
		if (vis[v]) continue;
		vis[v] = true;
		for (int i = head[v]; i!=-1; i = e[i].ne) {
			int j = e[i].to;
			if (dist[j] > dis + e[i].w) {
				dist[j] = dis + e[i].w;
				heap.push({dist[j], j});
			}
		}
	}
}
signed main(){
    int n,m,k;
    memset(head,-1,sizeof(head));
    cin >> n >> m >> k;
    for(int i=1;i<=m;i++){
        int op,x,y,z;
        cin >> op >> x >> y >> z;
        add(x+n*op,y+op*n,z);
        add(y+n*op,x+op*n,z);
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=2;j++){
            add(i,i+j*n,k);
            add(i+j*n,i,k);
        }
    }
    dijkstra(1);
    int t; 
    cin>>t; 
    vector<pair<int,int>>v(t); 
    for(int i=0;i<t;i++){
         int p,ti; 
         cin>>p>>ti; 
         v[i]={p,ti};
    }
    sort(v.begin(),v.end(),cmp); 
    for(int i=0;i<t-1;i++)
    {
        auto [x,y]=v[i]; 
        if(dist[x]<v[i].second){ 
            cout<<v[i].second; 
            return 0; 
        } else if(dist[x]<v[i+1].second)
        { 
            cout<<dist[x]; 
            return 0;
        } 
    } 
    if(dist[v[t-1].first]!=inf) 
        cout<<max(dist[v[t-1].first],v[t-1].second)<<endl; 
    else cout<<"-1"<<endl;
}
```


# L3-1计算几何的梦（质数，因子，二分）
> 队长是真这样做梦了，这道题只能说是一股清流，十分的友善，只不过大多数人都没看到这道题，给了暴力分。

__小tip: $x\sqrt[3]{y}$ =   $\sqrt[3]{z}$ 可以理解为求 $x^3*y=z$ 中 $x$的最大值__

### 结论：质数筛完$z^{1/4}$以内的质因子，剩下的全是完全立方数或者不可化简的数。 
### 证明：假设有因子 $p > z^{\frac{1}{4}}$ 则剩下的 $z$ 可以写为 $p^3*b$，这里$b$一定大于$z^{\frac{1}{4}}$，因为我们前面筛过$z^{\frac{1}{4}}$以内的因子， $p^3*b > z$不成立。 
### 所以我们只需要筛$z^{\frac{1}{4}}$之内的素数即可 ≈ 31650。 本题没有卡死素数范围，只要筛子在$31650-50000$左右都不会运行超时。

### 由于剩下的可能还有完全立方数，所以我们预处理了立方数的数组，最后去二分查询是否还有数的三次方等于$z$。

```c++
#include<bits/stdc++.h>
using namespace std;
#define ll long long
bool p[40000];
vector<int> ans;//保存素数
void ols(int n){
	p[1]=1;
	for(int i=2;i<=n;i++){
		if(!p[i]){
			ans.push_back(i);
		}
		for(int j=0;i*ans[j]<=n;j++){
			p[i*ans[j]]=1;
			if(i%ans[j]==0)break;
		}
	}
}
ll p3[1000010];//存三次方
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	ols(35000);//开大了会导致运行超时
	for(ll i=1;i<=1000000;i++)p3[i]=i*i*i;//预处理三次方
	int t;
	cin >> t;
	while(t--){
		ll z;
		cin >> z;
		ll ans1=1;
		for(int i=0;i<ans.size()&&ans[i]<=z;i++){
			int cs=0;
			while(z%ans[i]==0){
				cs++;
				z/=ans[i];
				if(cs==3)ans1*=ans[i],cs=0;
			}
		}//简单的素因子分解枚举
		ll l=0,r=1000000;
		while(l<r){
			int mid = (l+r) / 2;
			if(p3[mid] >= z){
				r=mid;
			}
			else l=mid+1;
		}//二分查找剩余
		if(l*l*l==z){
			cout << ans1*l << endl;
		}
		else cout << ans1<<endl;
	}
	
}
```


__后两题难度过高，有实力的选手可根据std自行理解__

# L3-2 不一样的过程（动态规划DP）
```c++
# include <bits/stdc++.h>
using ll = long long;
using namespace std;

const int mod = 1e9+7;
const int M = 5000;
const int N = 10010;
int l[51], r[51];
ll dp[51][51][N], pref[51][51][N];

void upd(int a, int b)
{
	for(int i=0;i<=10000;i++) 
	{
		if(i == 0) pref[a][b][i] = dp[a][b][i];
		else pref[a][b][i] = pref[a][b][i - 1] + dp[a][b][i];
		pref[a][b][i] %= mod;
	}
}

int calc(int a, int b, int c, int d) 
{
	d = min(d, 2 * M);
	c = max(c, 0);
	if(d < c) return 0;
	
	int as = pref[a][b][d];
	if(c > 0) as -= pref[a][b][c - 1];
	as %= mod;
	if(as < 0) as += mod;
	
	return as;
}
void solve()
{
	int n;cin>>n;
	for(int i=1;i<=n;i++) cin>>l[i]>>r[i];
	if(n == 1) 
	{
		cout<<r[n]-l[n]+1<<endl;
		return ;
	}
	
	for(int i=l[1];i<=r[1];i++) 
	{
		for(int j=l[n];j<=r[n];j++) dp[1][1][i - j + M]++;
	}
	upd(1, 1);
	
	for(int i=1;i<=n-1;i++) 
	{
		for(int j=1;i+j<=n;j++) 
		{
			if(i == 1 && j == 1) continue;
			for(int c=0;c<=2*M;c++)
			{
				if(c < M) 
				{
					dp[i][j][c] += calc(i - 1, j, c - r[i], c - l[i]);
					dp[i][j][c] %= mod;
					dp[i][j][c] += calc(i, j - 1, max(c + l[n - j + 1], M + 1), c + r[n - j + 1]);
					dp[i][j][c] %= mod;
				} 
				else if(c > M) 
				{
					dp[i][j][c] += calc(i - 1, j, c - r[i], min(c - l[i], M - 1));
					dp[i][j][c] %= mod;
					dp[i][j][c] += calc(i, j - 1, c + l[n - j + 1], c + r[n - j + 1]);
					dp[i][j][c] %= mod;
				}
			}
			upd(i, j);
		}
	}
	ll ans = 0;
	for(int i=1;i<=n-1;i++) 
	{
		for(int j=0;j<=2*M;j++) 
		{
			if(j == M) continue;
			ans += dp[i][n - i][j];
			ans %= mod;
		}
	}
	cout<<ans;
}
int main() {
	ios_base::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	int t=1;
	//cin>>t;
	while(t--) solve();
}
```
# L3-3 棋盘游戏（博弈）
```c++
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned long long
using namespace std;

const int N=1e6+5;

int n,k;
string s;

int sum=0;
int pw[13];
vector<vector<int>>trs[13];
map<vector<int>,int>mp[13];

bool isok(vector<int> a){
	int n=a.size();
	for(int i=0;i<n-1;i++) if(a[i]!=2 && a[i+1]!=2 && a[i]!=a[i+1]) return 0;
	return 1;
}

int dfs(vector<int> a){
	if(mp[k].count(a)) return mp[k][a];
	int s=0,n=a.size();
	for(int i=0;i<n;i++) if(a[i]==2) s|=(1<<i);
	for(int t=s;t;t=(t-1)&s){
		if(__builtin_popcount(t)%2==0)continue;
		for(int c=0;c<=1;c++){
			int mn=n+1,mx=-1;
			auto b = a;
			for(int j=0;j<n;j++) if(t>>j&1) b[j]=c,mn=min(mn,j),mx=max(mx,j);
			if(mx-mn>k) continue;
			if(isok(b) && !dfs(b)) return mp[k][a]=1;
		}
	}
	return mp[k][a]=0;
}

bool brute(int l,int r){
	vector<int> o;
	for(int i=l;i<=r;i++){
		if(s[i]=='W') o.push_back(2);
		if(s[i]=='R') o.push_back(1);
		if(s[i]=='G') o.push_back(0);
	}
	return dfs(o);
}

bool solve(int l,int r){
	if(r-l+1<=10)return brute(l,r);
	bool fl=(s[l]=='W' && s[l+1]=='W');
	bool fr=(s[r-1]=='W' && s[r]=='W');
	if(fl && fr) return solve(l+2,r-2);
	if(!fl && !fr){
		fl=(s[l]=='R'||s[l+1]=='R');
		fr=(s[r]=='R'||s[r-1]=='R');
		if((sum&1)==(fl==fr)) return 1;
		else return 0;
	}
	else return 1;
}

void solve()
{
	cin>>n>>k;
	cin>>s;
	s=' '+s;
	sum=0;
	for(int i=1;i<=n;i++) if(s[i]=='W')sum++;
	if(solve(1,n)) cout<<"Alice"<<'\n';
	else cout<<"Bob"<<'\n';
}

signed main()
{
	pw[0]=1;
	for(int i=1;i<=10;i++) pw[i]=pw[i-1]*3;
	int t;cin>>t;
	while(t--) solve();
}
```