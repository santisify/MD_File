## [寻找最长递增路径](https://www.lanqiao.cn/problems/10034/submissions/660fc703c9b906a33142b42f)
### 题目描述
> 给一个 $n * m$ 的矩阵，我们可以从任意一点出发，按照只能走比当前点权值更大的位置，并且只能走上、下、左、右是换个方向。
> 问：最多可可以走几步。
### 解题思路
> 由于矩阵较小，可以暴力枚举每个点出发能走的最大步数。对于单个点的最大步数可以用 `bfs` 求解。
### 参考代码

```cpp
#include <bits/stdc++.h>

#define int long long
#define endl '\n'
#define fix(n) std::fixed << std::setprecision(n)
[[maybe_unused]] const int inf = 1e17 + 50, MOD = 1e9 + 7;
[[maybe_unused]] typedef std::pair<int, int> pii;

int n, m, ans = -1;
std::vector<std::vector<int> > a;
int dx[] = { -1, 0, 0, 1 }, dy[] = { 0, -1, 1, 0 };
void dfs(int x, int y, int cnt, int w) {
    if (x < 0 || x >= n || y < 0 || y >= n) return;
    if (a[x][y] <= w) return;
    ans = std::max(ans, cnt);

    for (int i = 0; i < 4; i++) {
        int u = x + dx[i], v = y + dy[i];
        dfs(u, v, cnt + 1, a[x][y]);
    }
}

void solve() {
    std::cin >> n >> m;
    a = std::vector<std::vector<int> >(n, std::vector<int>(m));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            std::cin >> a[i][j];
        }
    }

    for (int i = 0; i < n; i++)
        for (int j = 0;j < m; j++) {
            dfs(i, j, 1, -1000);
        }

    std::cout << ans << endl;
}

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);
    int TT = 1;
    // std::cin >> TT;
    while (TT--)solve();
    return 0;
}
```

 